name: Build and Release

on:
  push:
    branches: [ main, snd ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'images/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    branches: [ main, Snd ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'images/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: self-hosted
    permissions:
      contents: write
    outputs:
      should_release: ${{ steps.check_release.outputs.should_release }}
      tag: ${{ steps.version.outputs.tag }}
      release_type: ${{ steps.version.outputs.release_type }}
      branch: ${{ steps.version.outputs.branch }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check required files exist
      run: |
        required_files=(
          "README.md"
          ".gitignore"
          "ESP32-P4-Allsky-Display.ino"
          "config.h"
          "config.cpp"
          "config_storage.h"
          "config_storage.cpp"
        )
        
        missing=0
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "‚ùå Missing required file: $file"
            missing=1
          fi
        done
        
        if [ $missing -eq 1 ]; then
          exit 1
        fi
        echo "‚úÖ All required files present"
    
    - name: Check for header/source pairs
      run: |
        for header in *.h; do
          base="${header%.h}"
          if [ "$base" != "web_config_html" ] && [ "$base" != "displays_config" ] && [ ! -f "${base}.cpp" ]; then
            echo "‚ö†Ô∏è Header $header has no matching .cpp file"
          fi
        done
        echo "‚úÖ Header/source check complete"
    
    - name: Validate file naming convention
      run: |
        invalid_count=0
        for file in *.cpp *.h *.ino; do
          if [ -f "$file" ]; then
            basename=$(basename "$file")
            if ! echo "$basename" | grep -qE "^[a-zA-Z0-9_-]+\.(cpp|h|ino)$"; then
              echo "‚ö†Ô∏è File not following naming convention: $basename"
              invalid_count=$((invalid_count + 1))
            fi
          fi
        done
        
        if [ $invalid_count -eq 0 ]; then
          echo "‚úÖ All files follow naming convention"
        else
          echo "‚ö†Ô∏è Found $invalid_count files with non-standard naming"
        fi
    
    - name: Setup Arduino CLI
      uses: arduino/setup-arduino-cli@v1
    
    - name: Cache Arduino CLI dependencies
      # Skip cache for self-hosted runners (files persist locally, no need to download 2.8GB cache)
      if: ${{ runner.name != 'git01' }}
      uses: actions/cache@v4
      with:
        path: |
          ~/.arduino15
          ~/Arduino/libraries
        key: ${{ runner.os }}-arduino-esp32-3.3.4-${{ hashFiles('**/*.ino', '**/*.cpp', '**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-arduino-esp32-3.3.4-
          ${{ runner.os }}-arduino-
    
    - name: Install ESP32 core
      run: |
        if [ ! -d ~/.arduino15/packages/esp32 ]; then
          arduino-cli core update-index --additional-urls https://espressif.github.io/arduino-esp32/package_esp32_index.json
          arduino-cli core install esp32:esp32@3.3.4 --additional-urls https://espressif.github.io/arduino-esp32/package_esp32_index.json
        else
          echo "‚úÖ ESP32 core already installed (cached)"
        fi
    
    - name: Install required libraries
      run: |
        if [ ! -d ~/Arduino/libraries/GFX_Library_for_Arduino ]; then
          arduino-cli lib install "GFX Library for Arduino"
        else
          echo "‚úÖ GFX Library already installed (cached)"
        fi
        
        if [ ! -d ~/Arduino/libraries/JPEGDEC ]; then
          arduino-cli lib install "JPEGDEC"
        else
          echo "‚úÖ JPEGDEC already installed (cached)"
        fi
        
        if [ ! -d ~/Arduino/libraries/PubSubClient ]; then
          arduino-cli lib install "PubSubClient"
        else
          echo "‚úÖ PubSubClient already installed (cached)"
        fi
        
        if [ ! -d ~/Arduino/libraries/ElegantOTA ]; then
          arduino-cli lib install "ElegantOTA"
        else
          echo "‚úÖ ElegantOTA already installed (cached)"
        fi
    
    - name: Patch GFX Library for ESP32-P4 compatibility
      run: |
        # Fix MIPI_DSI_PHY_CLK_SRC_DEFAULT compatibility issue
        sed -i 's/.phy_clk_src = MIPI_DSI_PHY_CLK_SRC_DEFAULT,/.phy_clk_src = MIPI_DSI_PHY_PLLREF_CLK_SRC_PLL_F20M, \/\/MIPI_DSI_PHY_CLK_SRC_DEFAULT,/' ~/Arduino/libraries/GFX_Library_for_Arduino/src/databus/Arduino_ESP32DSIPanel.cpp
        echo "‚úÖ GFX Library patched for ESP32-P4"
    
    - name: Determine if release should be created
      id: check_release
      run: |
        # Create release if:
        # 1. Manually triggered with create_release=true
        # 2. Push to main or snd branch (not PR)
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.create_release }}" = "true" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Release will be created (manual trigger)"
        elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Release will be created (push to main)"
        elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/snd" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Test release will be created (push to snd)"
        else
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "üî® Build only (no release)"
        fi
    
    - name: Get version tag for release
      id: version
      if: steps.check_release.outputs.should_release == 'true'
      run: |
        # Determine branch-specific tag prefix
        BRANCH_NAME="${GITHUB_REF#refs/heads/}"
        echo "Branch: $BRANCH_NAME"
        
        if [ "$BRANCH_NAME" = "main" ]; then
          TAG_PREFIX="v"
          TAG_PATTERN="v[0-9]*.[0-9]*"
          RELEASE_TYPE="stable"
        else
          TAG_PREFIX="v-${BRANCH_NAME}-"
          TAG_PATTERN="v-${BRANCH_NAME}-[0-9]*.[0-9]*"
          RELEASE_TYPE="test"
        fi
        
        # Get the latest tag for this branch
        LATEST_TAG=$(git tag -l "${TAG_PATTERN}" | sort -V | tail -n1)
        if [ -z "$LATEST_TAG" ]; then
          LATEST_TAG="${TAG_PREFIX}0.0"
        fi
        echo "Latest tag: $LATEST_TAG"
        
        # Extract version numbers (remove prefix first)
        VERSION="${LATEST_TAG#${TAG_PREFIX}}"
        IFS='.' read -ra PARTS <<< "$VERSION"
        MAJOR=${PARTS[0]:-0}
        MINOR=${PARTS[1]:-0}
        
        # Increment minor version by 1 (0.1 increments)
        MINOR=$((MINOR + 1))
        NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
        
        # Ensure the new tag doesn't already exist (keep incrementing if it does)
        while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
          echo "Tag $NEW_TAG already exists, incrementing..."
          MINOR=$((MINOR + 1))
          NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
        done
        
        echo "New tag: $NEW_TAG"
        echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
    
    - name: Update build information
      run: |
        # Get git information
        GIT_HASH=$(git rev-parse --short HEAD)
        GIT_HASH_FULL=$(git rev-parse HEAD)
        GIT_BRANCH="${GITHUB_REF#refs/heads/}"
        
        # Determine version to display (tag if releasing, otherwise commit)
        if [ "${{ steps.check_release.outputs.should_release }}" = "true" ] && [ -n "${{ steps.version.outputs.tag }}" ]; then
          DISPLAY_VERSION="${{ steps.version.outputs.tag }}"
        else
          DISPLAY_VERSION="${GIT_HASH}"
        fi
        
        # Update build_info.h
        cat > build_info.h << EOF
        // Auto-generated build information
        // This file is updated at compile time by the build workflow
        
        #ifndef BUILD_INFO_H
        #define BUILD_INFO_H
        
        // Build timestamp - will be populated by compiler
        #define BUILD_DATE __DATE__
        #define BUILD_TIME __TIME__
        
        // Git information (updated by CI/CD)
        #define GIT_COMMIT_HASH "${DISPLAY_VERSION}"
        #define GIT_COMMIT_FULL "${GIT_HASH_FULL}"
        #define GIT_BRANCH "${GIT_BRANCH}"
        
        #endif // BUILD_INFO_H
        EOF
        
        echo "‚úÖ Build info updated with version: ${DISPLAY_VERSION}"
    
    - name: Compile sketch
      id: compile
      run: |
        mkdir -p ./build ./release
        arduino-cli compile --fqbn esp32:esp32:esp32p4:PartitionScheme=app13M_data7M_32MB \
          --build-property "build.flash_size=32MB" \
          --build-property "build.psram_type=opi" \
          --build-property "compiler.cpp.extra_flags=-DBOARD_HAS_PSRAM" \
          --output-dir ./build \
          ESP32-P4-Allsky-Display.ino 2>&1 | tee compile_output.txt
        echo "‚úÖ Compilation successful"
    
    - name: Extract memory usage
      id: memory
      run: |
        # Extract flash usage
        FLASH_USED=$(grep "Sketch uses" compile_output.txt | grep -oP '\d+(?= bytes)' | head -1)
        FLASH_PERCENT=$(grep "Sketch uses" compile_output.txt | grep -oP '\d+(?=%)' | head -1)
        
        # Extract RAM usage
        RAM_USED=$(grep "Global variables use" compile_output.txt | grep -oP '\d+(?= bytes)' | head -1)
        RAM_PERCENT=$(grep "Global variables use" compile_output.txt | grep -oP '\d+(?=%)' | head -1)
        
        # Convert to KB for readability
        FLASH_KB=$((FLASH_USED / 1024))
        RAM_KB=$((RAM_USED / 1024))
        
        # Save to outputs
        echo "flash_used=${FLASH_USED}" >> $GITHUB_OUTPUT
        echo "flash_kb=${FLASH_KB}" >> $GITHUB_OUTPUT
        echo "flash_percent=${FLASH_PERCENT}" >> $GITHUB_OUTPUT
        echo "ram_used=${RAM_USED}" >> $GITHUB_OUTPUT
        echo "ram_kb=${RAM_KB}" >> $GITHUB_OUTPUT
        echo "ram_percent=${RAM_PERCENT}" >> $GITHUB_OUTPUT
        
        # Display results
        echo "üìä Memory Usage:"
        echo "Flash: ${FLASH_KB}KB (${FLASH_PERCENT}%)"
        echo "RAM: ${RAM_KB}KB (${RAM_PERCENT}%)"
    
    - name: Check for memory warnings
      run: |
        if grep -i "warning.*memory\|overflow" compile_output.txt; then
          echo "‚ö†Ô∏è Memory warnings detected"
          exit 1
        fi
        echo "‚úÖ No memory warnings"
    
    - name: Create memory usage badge data
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        mkdir -p .github/badges
        
        # Create JSON files for shields.io dynamic badges
        cat > .github/badges/flash-usage.json << EOF
        {
          "schemaVersion": 1,
          "label": "Flash",
          "message": "${{ steps.memory.outputs.flash_kb }}KB (${{ steps.memory.outputs.flash_percent }}%)",
          "color": "16537e"
        }
        EOF
        
        cat > .github/badges/ram-usage.json << EOF
        {
          "schemaVersion": 1,
          "label": "RAM",
          "message": "${{ steps.memory.outputs.ram_kb }}KB (${{ steps.memory.outputs.ram_percent }}%)",
          "color": "16537e"
        }
        EOF
        
        echo "‚úÖ Badge data created"
    
    - name: Commit badge data to repository
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add .github/badges/*.json
        git diff --quiet && git diff --staged --quiet || git commit -m "Update memory usage badges [skip ci]"
        git push
    
    - name: Prepare release binary
      if: steps.check_release.outputs.should_release == 'true'
      run: |
        # List build directory contents
        echo "Build directory contents:"
        ls -lh ./build/
        
        # Find and copy bin file with branch identifier
        BRANCH_NAME="${GITHUB_REF#refs/heads/}"
        if [ "$BRANCH_NAME" = "main" ]; then
          BIN_NAME="ESP32-P4-Allsky-Display-OTA.bin"
        else
          BIN_NAME="ESP32-P4-Allsky-Display-OTA-${BRANCH_NAME}.bin"
        fi
        
        # Find the main firmware .bin file (exclude bootloader and partitions)
        BIN_FILE=$(find ./build -name "ESP32-P4-Allsky-Display.ino.bin" -type f)
        if [ -z "$BIN_FILE" ]; then
          echo "‚ùå Error: ESP32-P4-Allsky-Display.ino.bin not found in build directory"
          echo "Available .bin files:"
          find ./build -name "*.bin" -type f
          exit 1
        fi
        
        echo "Found bin file: $BIN_FILE ($(du -h "$BIN_FILE" | cut -f1))"
        cp "$BIN_FILE" "release/$BIN_NAME"
        
        # Display build info
        ls -lh release/
        echo "‚úÖ OTA-ready firmware prepared: $BIN_NAME"
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ github.sha }}
        path: release/*.bin
        retention-days: 30
  
  release:
    needs: build
    if: needs.build.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: firmware-${{ github.sha }}
        path: release/
    
    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Check if tag exists (should not happen due to version increment logic)
        if git rev-parse "${{ needs.build.outputs.tag }}" >/dev/null 2>&1; then
          echo "‚ùå Error: Tag ${{ needs.build.outputs.tag }} already exists"
          echo "This should not happen - version increment logic failed"
          exit 1
        else
          git tag ${{ needs.build.outputs.tag }}
          git push origin ${{ needs.build.outputs.tag }}
          echo "‚úÖ Created and pushed tag ${{ needs.build.outputs.tag }}"
        fi
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.build.outputs.tag }}
        name: ${{ needs.build.outputs.release_type == 'test' && format('üß™ Test Release {0} ({1} branch)', needs.build.outputs.tag, needs.build.outputs.branch) || format('Release {0}', needs.build.outputs.tag) }}
        prerelease: ${{ needs.build.outputs.release_type == 'test' }}
        files: |
          release/*.bin
          README.md
          OTA_GUIDE.md
        body: |
          ${{ needs.build.outputs.release_type == 'test' && '## üß™ Test Release' || '## üì¶ ESP32-P4 AllSky Display' }} ${{ needs.build.outputs.tag }}
          
          ${{ needs.build.outputs.release_type == 'test' && format('‚ö†Ô∏è **This is a pre-release test build from the `{0}` branch.**', needs.build.outputs.branch) || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '**Use for testing purposes only. For stable releases, use builds from the main branch.**' || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '' || '' }}
          
          ### üöÄ Installation Methods
          
          #### Initial Installation (USB)
          1. Download the `.bin` file below
          2. Flash using esptool or Arduino IDE
          3. Configure WiFi via captive portal (device creates `AllSky-Display-Setup` network)
          
          #### OTA Update (Wireless) ‚ú®
          **Already have a previous version installed? Update wirelessly!**
          
          **Method 1: ElegantOTA (Recommended)**
          1. Navigate to `http://[device-ip]:8080/update`
          2. Upload the `.bin` file from this release
          3. Device reboots automatically with new firmware
          
          **Method 2: ArduinoOTA (For Developers)**
          1. Select network port in Arduino IDE: `Tools ‚Üí Port ‚Üí esp32-allsky-display at [IP]`
          2. Click Upload button
          
          ### ‚ú® Features
          - ‚úÖ **OTA Updates**: Update wirelessly via web interface or Arduino IDE
          - ‚úÖ **Safe A/B Partitioning**: Automatic rollback if update fails
          - ‚úÖ **Configuration Preserved**: WiFi, MQTT, and image settings survive updates
          - ‚úÖ **Multi-Image Cycling**: Display from up to 10 image sources
          - ‚úÖ **Home Assistant Integration**: Full MQTT discovery support
          - ‚úÖ **Touch Controls**: Single/double tap gestures
          - ‚úÖ **Hardware Acceleration**: ESP32-P4 PPA for fast image processing
          
          ### üìñ Documentation
          - [README.md](README.md) - Complete setup and features
          - [OTA_GUIDE.md](OTA_GUIDE.md) - Detailed OTA update instructions
          
          ### üîß Technical Details
          - **Partition Scheme**: 13MB app / 7MB data with A/B OTA support
          - **Flash Size**: 32MB
          - **PSRAM**: Required (OPI mode)
          - **Supported Displays**: Waveshare ESP32-P4 3.4" & 4.0" DSI touch displays
          ${{ needs.build.outputs.release_type == 'test' && format('- **Branch**: {0}', needs.build.outputs.branch) || '' }}
          
          ### üìù What's Changed
          See commit history for detailed changes in this release.
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
