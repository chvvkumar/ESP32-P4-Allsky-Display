name: Build and Release

on:
  push:
    branches: [ main, snd ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'images/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, snd, Dev ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'images/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  build:
    runs-on: self-hosted
    outputs:
      should_release: ${{ steps.check_release.outputs.should_release }}
      tag: ${{ steps.version.outputs.tag }}
      release_type: ${{ steps.version.outputs.release_type }}
      branch: ${{ steps.version.outputs.branch }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4.2.2
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check required files exist
      run: |
        required_files=(
          "README.md"
          ".gitignore"
          "ESP32-P4-Allsky-Display.ino"
          "config.h"
          "config.cpp"
          "config_storage.h"
          "config_storage.cpp"
        )
        
        missing=0
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "‚ùå Missing required file: $file"
            missing=1
          fi
        done
        
        if [ $missing -eq 1 ]; then
          exit 1
        fi
        echo "‚úÖ All required files present"
    
    - name: Check for header/source pairs
      run: |
        for header in *.h; do
          base="${header%.h}"
          if [ "$base" != "web_config_html" ] && [ "$base" != "displays_config" ] && [ ! -f "${base}.cpp" ]; then
            echo "‚ö†Ô∏è Header $header has no matching .cpp file"
          fi
        done
        echo "‚úÖ Header/source check complete"
    
    - name: Validate file naming convention
      run: |
        invalid_count=0
        for file in *.cpp *.h *.ino; do
          if [ -f "$file" ]; then
            basename=$(basename "$file")
            if ! echo "$basename" | grep -qE "^[a-zA-Z0-9_-]+\.(cpp|h|ino)$"; then
              echo "‚ö†Ô∏è File not following naming convention: $basename"
              invalid_count=$((invalid_count + 1))
            fi
          fi
        done
        
        if [ $invalid_count -eq 0 ]; then
          echo "‚úÖ All files follow naming convention"
        else
          echo "‚ö†Ô∏è Found $invalid_count files with non-standard naming"
        fi
    
    - name: Setup Arduino CLI
      uses: arduino/setup-arduino-cli@v2.0.0
      with:
        version: 1.3.1
    
    - name: Cache Arduino CLI dependencies
      # Skip cache for self-hosted runners (files persist locally, no need to download 2.8GB cache)
      if: ${{ runner.name != 'git01' }}
      uses: actions/cache@v4.2.0
      with:
        path: |
          ~/.arduino15
          ~/Arduino/libraries
        key: ${{ runner.os }}-arduino-esp32-3.3.4-${{ hashFiles('**/*.ino', '**/*.cpp', '**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-arduino-esp32-3.3.4-
          ${{ runner.os }}-arduino-
    
    - name: Install ESP32 core
      run: |
        if [ ! -d ~/.arduino15/packages/esp32 ]; then
          arduino-cli core update-index --additional-urls https://espressif.github.io/arduino-esp32/package_esp32_index.json
          arduino-cli core install esp32:esp32@3.3.4 --additional-urls https://espressif.github.io/arduino-esp32/package_esp32_index.json
        else
          echo "‚úÖ ESP32 core already installed (cached)"
        fi
    
    - name: Install required libraries
      run: |
        # Check and install GFX Library for Arduino 1.6.0
        if [ -d ~/Arduino/libraries/GFX_Library_for_Arduino ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "GFX Library for Arduino" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "1.6.0" ]; then
            echo "‚úÖ GFX Library for Arduino 1.6.0 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 1.6.0"
            arduino-cli lib install "GFX Library for Arduino@1.6.0"
          fi
        else
          arduino-cli lib install "GFX Library for Arduino@1.6.0"
        fi
        
        # Check and install JPEGDEC 1.8.2
        if [ -d ~/Arduino/libraries/JPEGDEC ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "JPEGDEC" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "1.8.2" ]; then
            echo "‚úÖ JPEGDEC 1.8.2 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 1.8.2"
            arduino-cli lib install "JPEGDEC@1.8.2"
          fi
        else
          arduino-cli lib install "JPEGDEC@1.8.2"
        fi
        
        # Check and install PubSubClient 2.8
        if [ -d ~/Arduino/libraries/PubSubClient ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "PubSubClient" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "2.8" ] || [ "$INSTALLED_VERSION" = "2.8.0" ]; then
            echo "‚úÖ PubSubClient 2.8 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 2.8"
            arduino-cli lib install "PubSubClient@2.8"
          fi
        else
          arduino-cli lib install "PubSubClient@2.8"
        fi
        
        # Check and install ElegantOTA 3.1.7
        if [ -d ~/Arduino/libraries/ElegantOTA ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "ElegantOTA" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "3.1.7" ]; then
            echo "‚úÖ ElegantOTA 3.1.7 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 3.1.7"
            arduino-cli lib install "ElegantOTA@3.1.7"
          fi
        else
          arduino-cli lib install "ElegantOTA@3.1.7"
        fi
        
        # Check and install WebSockets 2.7.1
        if [ -d ~/Arduino/libraries/WebSockets ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "WebSockets" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "2.7.1" ]; then
            echo "‚úÖ WebSockets 2.7.1 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 2.7.1"
            arduino-cli lib install "WebSockets@2.7.1"
          fi
        else
          arduino-cli lib install "WebSockets@2.7.1"
        fi
        
        # Check and install ArduinoJson 7.2.1
        if [ -d ~/Arduino/libraries/ArduinoJson ]; then
          INSTALLED_VERSION=$(arduino-cli lib list | grep "ArduinoJson" | awk '{print $2}')
          if [ "$INSTALLED_VERSION" = "7.2.1" ]; then
            echo "‚úÖ ArduinoJson 7.2.1 already installed (cached)"
          else
            echo "‚ö†Ô∏è Wrong version ($INSTALLED_VERSION), installing 7.2.1"
            arduino-cli lib install "ArduinoJson@7.2.1"
          fi
        else
          arduino-cli lib install "ArduinoJson@7.2.1"
        fi
        
        # Verify installed versions
        echo ""
        echo "üì¶ Final installed library versions:"
        arduino-cli lib list | grep -E "GFX Library|JPEGDEC|PubSubClient|ElegantOTA|WebSockets|ArduinoJson"
    
    - name: Patch GFX Library for ESP32-P4 compatibility
      run: |
        # Fix MIPI_DSI_PHY_CLK_SRC_DEFAULT compatibility issue
        sed -i 's/.phy_clk_src = MIPI_DSI_PHY_CLK_SRC_DEFAULT,/.phy_clk_src = MIPI_DSI_PHY_PLLREF_CLK_SRC_PLL_F20M, \/\/MIPI_DSI_PHY_CLK_SRC_DEFAULT,/' ~/Arduino/libraries/GFX_Library_for_Arduino/src/databus/Arduino_ESP32DSIPanel.cpp
        echo "‚úÖ GFX Library patched for ESP32-P4"
    
    - name: Determine if release should be created
      id: check_release
      run: |
        # Create release if:
        # 1. Manually triggered with create_release=true
        # 2. Push to main or snd branch (not PR)
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.create_release }}" = "true" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Release will be created (manual trigger)"
        elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Release will be created (push to main)"
        elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/snd" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "üì¶ Test release will be created (push to snd)"
        else
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "üî® Build only (no release)"
        fi
    
    - name: Get version tag for release
      id: version
      if: steps.check_release.outputs.should_release == 'true'
      run: |
        # Fetch all tags to ensure we have complete tag history
        git fetch --tags --force
        
        # Determine branch-specific tag prefix
        BRANCH_NAME="${GITHUB_REF#refs/heads/}"
        echo "Branch: $BRANCH_NAME"
        
        if [ "$BRANCH_NAME" = "main" ]; then
          TAG_PREFIX="v"
          TAG_PATTERN="v[0-9]*.[0-9]*"
          RELEASE_TYPE="stable"
        else
          TAG_PREFIX="v-${BRANCH_NAME}-"
          TAG_PATTERN="v-${BRANCH_NAME}-[0-9]*.[0-9]*"
          RELEASE_TYPE="test"
        fi
        
        # Get all matching tags and find the highest version
        echo "Looking for tags matching pattern: ${TAG_PATTERN}"
        LATEST_TAG=$(git tag -l "${TAG_PATTERN}" | sort -V | tail -n1)
        
        if [ -z "$LATEST_TAG" ]; then
          # No existing tags, start at 0.1
          MAJOR=0
          MINOR=0
          echo "No existing tags found, starting at ${TAG_PREFIX}0.1"
        else
          echo "Latest tag: $LATEST_TAG"
          # Extract version numbers (remove prefix first)
          VERSION="${LATEST_TAG#${TAG_PREFIX}}"
          IFS='.' read -ra PARTS <<< "$VERSION"
          MAJOR=${PARTS[0]:-0}
          MINOR=${PARTS[1]:-0}
          echo "Current version: $MAJOR.$MINOR"
        fi
        
        # Increment minor version by 1 (0.1 increments)
        MINOR=$((MINOR + 1))
        NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
        
        # Ensure the new tag doesn't already exist (keep incrementing if it does)
        ATTEMPTS=0
        while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
          echo "‚ö†Ô∏è Tag $NEW_TAG already exists, incrementing..."
          MINOR=$((MINOR + 1))
          NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
          ATTEMPTS=$((ATTEMPTS + 1))
          if [ $ATTEMPTS -gt 100 ]; then
            echo "‚ùå Error: Too many version increment attempts"
            exit 1
          fi
        done
        
        echo "‚úÖ New tag: $NEW_TAG"
        echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
    
    - name: Update build information
      run: |
        # Get git information
        GIT_HASH=$(git rev-parse --short HEAD)
        GIT_HASH_FULL=$(git rev-parse HEAD)
        GIT_BRANCH="${GITHUB_REF#refs/heads/}"
        
        # Determine version to display (tag if releasing, otherwise commit)
        if [ "${{ steps.check_release.outputs.should_release }}" = "true" ] && [ -n "${{ steps.version.outputs.tag }}" ]; then
          DISPLAY_VERSION="${{ steps.version.outputs.tag }}"
        else
          DISPLAY_VERSION="${GIT_HASH}"
        fi
        
        # Update build_info.h
        cat > build_info.h << EOF
        // Auto-generated build information
        // This file is updated at compile time by the build workflow
        
        #ifndef BUILD_INFO_H
        #define BUILD_INFO_H
        
        // Build timestamp - will be populated by compiler
        #define BUILD_DATE __DATE__
        #define BUILD_TIME __TIME__
        
        // Git information (updated by CI/CD)
        #define GIT_COMMIT_HASH "${DISPLAY_VERSION}"
        #define GIT_COMMIT_FULL "${GIT_HASH_FULL}"
        #define GIT_BRANCH "${GIT_BRANCH}"
        
        #endif // BUILD_INFO_H
        EOF
        
        echo "‚úÖ Build info updated with version: ${DISPLAY_VERSION}"
    
    - name: Compile sketch
      id: compile
      run: |
        mkdir -p ./build ./release
        arduino-cli compile --fqbn esp32:esp32:esp32p4:FlashSize=32M,PartitionScheme=app13M_data7M_32MB,PSRAM=enabled \
          --output-dir ./build \
          ESP32-P4-Allsky-Display.ino 2>&1 | tee compile_output.txt
        echo "‚úÖ Compilation successful"
    
    - name: Extract memory usage
      id: memory
      run: |
        # Extract flash usage
        FLASH_USED=$(grep "Sketch uses" compile_output.txt | grep -oP '\d+(?= bytes)' | head -1)
        FLASH_PERCENT=$(grep "Sketch uses" compile_output.txt | grep -oP '\d+(?=%)' | head -1)
        
        # Extract RAM usage
        RAM_USED=$(grep "Global variables use" compile_output.txt | grep -oP '\d+(?= bytes)' | head -1)
        RAM_PERCENT=$(grep "Global variables use" compile_output.txt | grep -oP '\d+(?=%)' | head -1)
        
        # Convert to KB for readability
        FLASH_KB=$((FLASH_USED / 1024))
        RAM_KB=$((RAM_USED / 1024))
        
        # Save to outputs
        echo "flash_used=${FLASH_USED}" >> $GITHUB_OUTPUT
        echo "flash_kb=${FLASH_KB}" >> $GITHUB_OUTPUT
        echo "flash_percent=${FLASH_PERCENT}" >> $GITHUB_OUTPUT
        echo "ram_used=${RAM_USED}" >> $GITHUB_OUTPUT
        echo "ram_kb=${RAM_KB}" >> $GITHUB_OUTPUT
        echo "ram_percent=${RAM_PERCENT}" >> $GITHUB_OUTPUT
        
        # Display results
        echo "üìä Memory Usage:"
        echo "Flash: ${FLASH_KB}KB (${FLASH_PERCENT}%)"
        echo "RAM: ${RAM_KB}KB (${RAM_PERCENT}%)"
    
    - name: Check for memory warnings
      run: |
        if grep -i "warning.*memory\|overflow" compile_output.txt; then
          echo "‚ö†Ô∏è Memory warnings detected"
          exit 1
        fi
        echo "‚úÖ No memory warnings"
    
    - name: Create memory usage badge data
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        mkdir -p .github/badges
        
        # Create JSON files for shields.io dynamic badges
        cat > .github/badges/flash-usage.json << EOF
        {
          "schemaVersion": 1,
          "label": "Flash",
          "message": "${{ steps.memory.outputs.flash_kb }}KB (${{ steps.memory.outputs.flash_percent }}%)",
          "color": "16537e"
        }
        EOF
        
        cat > .github/badges/ram-usage.json << EOF
        {
          "schemaVersion": 1,
          "label": "RAM",
          "message": "${{ steps.memory.outputs.ram_kb }}KB (${{ steps.memory.outputs.ram_percent }}%)",
          "color": "16537e"
        }
        EOF
        
        echo "‚úÖ Badge data created"
    
    - name: Commit badge data to badges branch
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        # Configure git
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Save current commit SHA and badge files
        CURRENT_SHA=${{ github.sha }}
        CURRENT_BRANCH=${{ github.ref_name }}
        
        # Copy badge files to temp location
        mkdir -p /tmp/badges
        cp .github/badges/*.json /tmp/badges/
        
        # Stash any local changes to avoid checkout conflicts
        git stash push -u -m "Stash build artifacts before badges branch checkout"
        
        # Try to fetch badges branch, if it doesn't exist we'll create it
        if git fetch origin badges 2>/dev/null; then
          echo "‚úÖ Badges branch exists, checking it out"
          git checkout badges
        else
          echo "üì¶ Creating new badges branch"
          git checkout --orphan badges
          git rm -rf . 2>/dev/null || true
        fi
        
        # Ensure badges directory exists and copy files
        mkdir -p .github/badges
        cp /tmp/badges/*.json .github/badges/
        
        # Create a simple README for the badges branch
        cat > README.md << 'EOFREADME'
        # Badges Branch
        
        This branch contains auto-generated badge data for the ESP32-P4 AllSky Display project.
        
        Do not manually edit this branch - it is automatically updated by GitHub Actions.
        EOFREADME
        
        # Commit and push changes
        git add .github/badges/*.json README.md
        if git diff --quiet && git diff --staged --quiet; then
          echo "‚ÑπÔ∏è No changes to badge data"
        else
          git commit -m "Update memory usage badges from ${CURRENT_SHA:0:7}"
          git push origin badges
          echo "‚úÖ Badge data pushed to badges branch"
        fi
        
        # Return to original branch
        git checkout ${CURRENT_BRANCH}
        
        # Restore stashed changes
        git stash pop || echo "‚ÑπÔ∏è No stash to restore"
    
    - name: Prepare release binary
      if: steps.check_release.outputs.should_release == 'true'
      run: |
        # Ensure release directory exists
        mkdir -p ./release
        
        # List build directory contents
        echo "Build directory contents:"
        ls -lh ./build/
        
        # Find and copy bin file with branch identifier
        BRANCH_NAME="${GITHUB_REF#refs/heads/}"
        if [ "$BRANCH_NAME" = "main" ]; then
          BIN_NAME="ESP32-P4-Allsky-Display-OTA.bin"
        else
          BIN_NAME="ESP32-P4-Allsky-Display-OTA-${BRANCH_NAME}.bin"
        fi
        
        # Find the main firmware .bin file (exclude bootloader and partitions)
        BIN_FILE=$(find ./build -name "ESP32-P4-Allsky-Display.ino.bin" -type f)
        if [ -z "$BIN_FILE" ]; then
          echo "‚ùå Error: ESP32-P4-Allsky-Display.ino.bin not found in build directory"
          echo "Available .bin files:"
          find ./build -name "*.bin" -type f
          exit 1
        fi
        
        echo "Found bin file: $BIN_FILE ($(du -h "$BIN_FILE" | cut -f1))"
        cp "$BIN_FILE" "release/$BIN_NAME"
        
        # Display build info
        ls -lh release/
        echo "‚úÖ OTA-ready firmware prepared: $BIN_NAME"
    
    - name: Upload build artifacts
      if: steps.check_release.outputs.should_release == 'true'
      uses: actions/upload-artifact@v4.6.0
      with:
        name: firmware-${{ github.sha }}
        path: release/*.bin
        retention-days: 30
  
  release:
    needs: build
    if: needs.build.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4.2.2
      with:
        fetch-depth: 0
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4.1.8
      with:
        name: firmware-${{ github.sha }}
        path: release/
    
    - name: Generate commit history
      id: changelog
      run: |
        # Get the previous tag for this branch (excluding the tag we're about to create)
        TAG_PREFIX="${{ needs.build.outputs.release_type == 'test' && format('{0}-', needs.build.outputs.branch) || '' }}v"
        TAG_PATTERN="${TAG_PREFIX}*"
        NEW_TAG="${{ needs.build.outputs.tag }}"
        
        # Get all matching tags, exclude the new tag if it exists, and get the latest
        PREVIOUS_TAG=$(git tag -l "${TAG_PATTERN}" | grep -v "^${NEW_TAG}$" | sort -V | tail -n1)
        
        if [ -z "$PREVIOUS_TAG" ]; then
          echo "No previous tag found, showing last 20 commits"
          COMMITS=$(git log -20 --pretty=format:"- %s (%h)" --no-merges)
        else
          echo "Generating changelog from $PREVIOUS_TAG to HEAD"
          COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          
          # If no commits found, it means we're on the same commit
          if [ -z "$COMMITS" ]; then
            echo "No new commits since $PREVIOUS_TAG"
            COMMITS="- No changes since previous release"
          fi
        fi
        
        # Save to output using heredoc to handle multiline
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Check if tag exists (should not happen due to version increment logic)
        if git rev-parse "${{ needs.build.outputs.tag }}" >/dev/null 2>&1; then
          echo "‚ùå Error: Tag ${{ needs.build.outputs.tag }} already exists"
          echo "This should not happen - version increment logic failed"
          exit 1
        else
          git tag ${{ needs.build.outputs.tag }}
          git push origin ${{ needs.build.outputs.tag }}
          echo "‚úÖ Created and pushed tag ${{ needs.build.outputs.tag }}"
        fi
    
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.build.outputs.tag }}
        name: ${{ needs.build.outputs.release_type == 'test' && format('üß™ Test Release {0} ({1} branch)', needs.build.outputs.tag, needs.build.outputs.branch) || format('Release {0}', needs.build.outputs.tag) }}
        prerelease: ${{ needs.build.outputs.release_type == 'test' }}
        files: |
          release/*.bin
          README.md
          OTA_GUIDE.md
        body: |
          ${{ needs.build.outputs.release_type == 'test' && '## üß™ Test Release' || '## üì¶ ESP32-P4 AllSky Display' }} ${{ needs.build.outputs.tag }}
          
          ${{ needs.build.outputs.release_type == 'test' && format('‚ö†Ô∏è **This is a pre-release test build from the `{0}` branch.**', needs.build.outputs.branch) || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '**Use for testing purposes only. For stable releases, use builds from the main branch.**' || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '' || '' }}
          
          ### ‚ö†Ô∏è Display Compatibility
          
          **Pre-compiled firmware is configured for the 3.4" display (800√ó800) only.**
          
          - ‚úÖ **3.4" Waveshare Display**: Use the `.bin` file below
          - ‚ùå **4.0" Waveshare Display**: Must compile from source (see README.md)
          - Display configuration is set at compile time and cannot be changed after flashing
          
          ### üöÄ Installation Methods
          
          #### Initial Installation (USB)
          1. Download the `.bin` file below (for 3.4" display only)
          2. Flash using esptool or Arduino IDE
          3. Configure WiFi via captive portal (device creates `AllSky-Display-Setup` network)
          
          #### OTA Update (Wireless) ‚ú®
          **Already have a previous version installed? Update wirelessly!**
          
          **Method 1: ElegantOTA (Recommended)**
          1. Navigate to `http://[device-ip]:8080/update`
          2. Upload the `.bin` file from this release
          3. Device reboots automatically with new firmware
          
          **Method 2: ArduinoOTA (For Developers)**
          1. Select network port in Arduino IDE: `Tools ‚Üí Port ‚Üí esp32-allsky-display at [IP]`
          2. Click Upload button
          
          ### Key Features
          - **Over-the-Air Updates**: Wireless firmware updates via web interface or Arduino IDE with automatic rollback protection
          - **Dual Partition System**: Safe A/B partition scheme ensures system stability during updates
          - **Persistent Configuration**: Network credentials, MQTT settings, and display preferences are preserved across firmware updates
          - **Multi-Source Image Display**: Support for up to 10 configurable image sources with automatic cycling
          - **Home Assistant Integration**: Native MQTT auto-discovery for seamless smart home integration
          - **Touch Interface**: Responsive single and double-tap gesture controls
          - **Hardware-Accelerated Processing**: Leverages ESP32-P4 PPA engine for optimized image transformation
          
          ### Documentation
          - [README.md](README.md) - Complete setup and features
          - [OTA_GUIDE.md](OTA_GUIDE.md) - Detailed OTA update instructions
          
          ### üîß Technical Details
          - **Partition Scheme**: 13MB app / 7MB data with A/B OTA support
          - **Flash Size**: 32MB
          - **PSRAM**: Required (OPI mode)
          - **Supported Displays**: Waveshare ESP32-P4 3.4" & 4.0" DSI touch displays
          ${{ needs.build.outputs.release_type == 'test' && format('- **Branch**: {0}', needs.build.outputs.branch) || '' }}
          
          ### Changes in This Release
          ${{ steps.changelog.outputs.changelog || '_No commits found_' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  pr-commit-summary:
    name: Generate PR Summary
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Collect commit information
        id: collect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching commits for PR #${{ github.event.pull_request.number }}"
          
          # Get detailed commit information
          gh pr view ${{ github.event.pull_request.number }} --json commits \
            --jq '.commits[] | "**Commit \(.oid[0:7])** by \(.authors[0].name // "Unknown")\nMessage: \(.messageHeadline)\n\(.messageBody // "")\n---"' \
            > commits.txt
          
          # Get changed files with stats
          gh pr view ${{ github.event.pull_request.number }} --json files \
            --jq '.files[] | "- `\(.path)` (+\(.additions)/-\(.deletions))"' \
            > files.txt
          
          # Get commit count
          COMMIT_COUNT=$(gh pr view ${{ github.event.pull_request.number }} --json commits --jq '.commits | length')
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          
          echo "Collected $COMMIT_COUNT commits"

      - name: Generate summary with OpenAI
        id: summarize
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Read collected data
          COMMITS=$(cat commits.txt)
          FILES=$(cat files.txt)
          
          # Escape special characters for JSON
          COMMITS_ESCAPED=$(echo "$COMMITS" | jq -Rs .)
          FILES_ESCAPED=$(echo "$FILES" | jq -Rs .)
          PR_TITLE=$(echo "${{ github.event.pull_request.title }}" | jq -Rs .)
          PR_BODY=$(echo "${{ github.event.pull_request.body }}" | jq -Rs .)
          
          # Build the prompt
          read -r -d '' PROMPT << 'EOF'
          You are a code review assistant. Analyze the following pull request and provide a comprehensive summary.

          ## Pull Request Details
          **Title:** %PR_TITLE%
          **Description:** %PR_BODY%

          ## Commits in this PR
          %COMMITS%

          ## Files Changed
          %FILES%

          ## Your Task
          Provide a well-structured summary with these sections:

          ### üìã Overview
          Write 2-3 sentences describing what this PR accomplishes overall.

          ### üîÑ Changes by Category
          Group the changes into relevant categories such as:
          - **Features**: New functionality added
          - **Bug Fixes**: Issues resolved
          - **Refactoring**: Code improvements without behavior changes
          - **Documentation**: README, comments, docs updates
          - **Tests**: Test additions or modifications
          - **Dependencies**: Package or dependency changes
          - **Configuration**: Config file changes

          Only include categories that apply. Use bullet points for each change.

          ### ‚ö†Ô∏è Notable Details
          Highlight any:
          - Breaking changes
          - Security considerations
          - Performance implications
          - Migration requirements

          If none, write "No notable concerns identified."

          ### üëÄ Suggested Review Focus
          List 2-4 specific areas or files reviewers should pay close attention to.

          Format everything in clean markdown.
          EOF
          
          # Replace placeholders (remove jq quotes)
          PROMPT="${PROMPT//%PR_TITLE%/$(echo $PR_TITLE | jq -r .)}"
          PROMPT="${PROMPT//%PR_BODY%/$(echo $PR_BODY | jq -r .)}"
          PROMPT="${PROMPT//%COMMITS%/$(echo $COMMITS_ESCAPED | jq -r .)}"
          PROMPT="${PROMPT//%FILES%/$(echo $FILES_ESCAPED | jq -r .)}"
          
          # Make API request
          RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$(jq -n \
              --arg prompt "$PROMPT" \
              '{
                model: "gpt-4o",
                messages: [
                  {
                    role: "system",
                    content: "You are a helpful assistant that summarizes pull requests for code reviewers. Be concise but thorough. Use markdown formatting."
                  },
                  {
                    role: "user",
                    content: $prompt
                  }
                ],
                max_tokens: 1500,
                temperature: 0.3
              }')")
          
          # Debug: Show response status (without exposing full response)
          if [ -z "$RESPONSE" ]; then
            echo "‚ùå Error: Empty response from OpenAI API"
            exit 1
          fi
          
          # Check for errors
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ùå Error from OpenAI API:"
            echo "$RESPONSE" | jq '.error'
            exit 1
          fi
          
          # Check if response has choices
          if ! echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            echo "‚ùå Error: Invalid response structure from OpenAI"
            echo "Response keys: $(echo "$RESPONSE" | jq -r 'keys | @json')"
            exit 1
          fi
          
          # Extract summary
          echo "$RESPONSE" | jq -r '.choices[0].message.content' > summary.md
          
          echo "‚úÖ Summary generated successfully"

      - name: Post summary to PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read the generated summary
            const summary = fs.readFileSync('summary.md', 'utf8');
            const commitCount = '${{ steps.collect.outputs.commit_count }}';
            
            // Create comment body with identifier marker
            const marker = '<!-- pr-commit-summary-bot -->';
            const timestamp = new Date().toISOString();
            
            const body = `${marker}
            ## ü§ñ PR Commit Summary
            
            ${summary}
            
            ---
            <sub>üìä Analyzed **${commitCount}** commit(s) | üïê Updated: ${timestamp} | Generated by GitHub Actions</sub>`;
            
            // Look for existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes(marker)
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
              console.log(`Updated existing comment: ${existingComment.id}`);
            } else {
              // Create new comment
              const { data: newComment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
              console.log(`Created new comment: ${newComment.id}`);
            }
